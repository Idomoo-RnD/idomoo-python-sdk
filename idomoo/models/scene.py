# coding: utf-8

"""
    Idomoo API



    OpenAPI spec version: 2.0
    Contact: dev.support@idomoo.com

"""


import pprint

import six

from idomoo.models.audio import Audio
from idomoo.models.media import Media
from idomoo.models.text import Text


class Scene(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'scene_id': 'int',
        'unique_scene_id': 'str',
        'z_index': 'int',
        'duration_in_seconds': 'float',
        'start_time_offset_unique_scene_id': 'str',
        'start_time_offset_seconds': 'float',
        'start_time_in_seconds': 'float',
        'scene_start_in_seconds': 'float',
        'media': 'list[Media]',
        'text': 'list[Text]',
        'audio': 'list[Audio]'
    }

    attribute_map = {
        'scene_id': 'scene_id',
        'unique_scene_id': 'unique_scene_id',
        'z_index': 'z_index',
        'duration_in_seconds': 'duration_in_seconds',
        'start_time_offset_unique_scene_id': 'start_time_offset_unique_scene_id',
        'start_time_offset_seconds': 'start_time_offset_seconds',
        'start_time_in_seconds': 'start_time_in_seconds',
        'scene_start_in_seconds': 'scene_start_in_seconds',
        'media': 'media',
        'text': 'text',
        'audio': 'audio'
    }

    def __init__(self, scene_id, unique_scene_id=None, z_index=None, duration_in_seconds=None,
                 start_time_offset_unique_scene_id=None, start_time_offset_seconds=None, start_time_in_seconds=None,
                 scene_start_in_seconds=None, media=None, text=None, audio=None):
        """Scene - a model defined in Swagger"""

        self._scene_id = None
        self._unique_scene_id = None
        self._z_index = None
        self._duration_in_seconds = None
        self._start_time_offset_unique_scene_id = None
        self._start_time_offset_seconds = None
        self._start_time_in_seconds = None
        self._scene_start_in_seconds = None
        self._media = None
        self._text = None
        self._audio = None
        self.discriminator = None

        self.scene_id = scene_id
        if unique_scene_id is not None:
            self.unique_scene_id = unique_scene_id
        if z_index is not None:
            self.z_index = z_index
        if duration_in_seconds is not None:
            self.duration_in_seconds = duration_in_seconds
        if start_time_offset_unique_scene_id is not None:
            self.start_time_offset_unique_scene_id = start_time_offset_unique_scene_id
        if start_time_offset_seconds is not None:
            self.start_time_offset_seconds = start_time_offset_seconds
        if start_time_in_seconds is not None:
            self.start_time_in_seconds = start_time_in_seconds
        if scene_start_in_seconds is not None:
            self.scene_start_in_seconds = scene_start_in_seconds
        if media is not None:
            self.media = media
        if text is not None:
            self.text = text
        if audio is not None:
            self.audio = audio

    @property
    def scene_id(self):
        """Gets the scene_id of this Scene.

        The numeric scene ID created after the scene upload.

        :return: The scene_id of this Scene.
        :rtype: int
        """
        return self._scene_id

    @scene_id.setter
    def scene_id(self, scene_id):
        """Sets the scene_id of this Scene.

        The numeric scene ID created after the scene upload.

        :param scene_id: The scene_id of this Scene.
        :type: int
        """
        if scene_id is None:
            raise ValueError("Invalid value for `scene_id`, must not be `None`")

        self._scene_id = scene_id

    @property
    def unique_scene_id(self):
        """Gets the unique_scene_id of this Scene.

        As the same scene can be used several time, the unique scene ID is a way for the developer to identify this
        specific use of the scene. Must be used for `\"start_time_offset_unique_scene_id\"` to work.

        :return: The unique_scene_id of this Scene.
        :rtype: str
        """
        return self._unique_scene_id

    @unique_scene_id.setter
    def unique_scene_id(self, unique_scene_id):
        """Sets the unique_scene_id of this Scene.

        As the same scene can be used several time, the unique scene ID is a way for the developer to identify this
        specific use of the scene. Must be used for `\"start_time_offset_unique_scene_id\"` to work.

        :param unique_scene_id: The unique_scene_id of this Scene.
        :type: str
        """

        self._unique_scene_id = unique_scene_id

    @property
    def z_index(self):
        """Gets the z_index of this Scene.

        When layering scene on top of scene a scene with a higher Z index will be on top of a scene with a
        lower Z index.

        :return: The z_index of this Scene.
        :rtype: int
        """
        return self._z_index

    @z_index.setter
    def z_index(self, z_index):
        """Sets the z_index of this Scene.

        When layering scene on top of scene a scene with a higher Z index will be on top of a scene with a
        lower Z index.

        :param z_index: The z_index of this Scene.
        :type: int
        """

        self._z_index = z_index

    @property
    def duration_in_seconds(self):
        """Gets the duration_in_seconds of this Scene.

        Duration of the scene to use in seconds. By default, the full duration is used.

        :return: The duration_in_seconds of this Scene.
        :rtype: float
        """
        return self._duration_in_seconds

    @duration_in_seconds.setter
    def duration_in_seconds(self, duration_in_seconds):
        """Sets the duration_in_seconds of this Scene.

        Duration of the scene to use in seconds. By default, the full duration is used.

        :param duration_in_seconds: The duration_in_seconds of this Scene.
        :type: float
        """
        if duration_in_seconds is not None and duration_in_seconds < 0:
            raise ValueError("Invalid value for `duration_in_seconds`, must be a value greater than or equal to `0`")

        self._duration_in_seconds = duration_in_seconds

    @property
    def start_time_offset_unique_scene_id(self):
        """Gets the start_time_offset_unique_scene_id of this Scene.

        To start this scene when another scene ends, use the other scene's `\"unique_scene_id\"` here. Must not be
        used with `\"start_time_in_seconds\"`.

        :return: The start_time_offset_unique_scene_id of this Scene.
        :rtype: str
        """
        return self._start_time_offset_unique_scene_id

    @start_time_offset_unique_scene_id.setter
    def start_time_offset_unique_scene_id(self, start_time_offset_unique_scene_id):
        """Sets the start_time_offset_unique_scene_id of this Scene.

        To start this scene when another scene ends, use the other scene's `\"unique_scene_id\"` here. Must not be
        used with `\"start_time_in_seconds\"`.

        :param start_time_offset_unique_scene_id: The start_time_offset_unique_scene_id of this Scene.
        :type: str
        """

        self._start_time_offset_unique_scene_id = start_time_offset_unique_scene_id

    @property
    def start_time_offset_seconds(self):
        """Gets the start_time_offset_seconds of this Scene.

        Offset in seconds from when the scene specified in `\"start_time_offset_unique_scene_id\"` ends. Can be used
        with negative values.

        :return: The start_time_offset_seconds of this Scene.
        :rtype: float
        """
        return self._start_time_offset_seconds

    @start_time_offset_seconds.setter
    def start_time_offset_seconds(self, start_time_offset_seconds):
        """Sets the start_time_offset_seconds of this Scene.

        Offset in seconds from when the scene specified in `\"start_time_offset_unique_scene_id\"` ends. Can be used
        with negative values.

        :param start_time_offset_seconds: The start_time_offset_seconds of this Scene.
        :type: float
        """

        self._start_time_offset_seconds = start_time_offset_seconds

    @property
    def start_time_in_seconds(self):
        """Gets the start_time_in_seconds of this Scene.

        Absolute time for the scene to start. Can't be sent with `\"start_time_offset_unique_scene_id\"` and
        `\"start_time_offset_seconds\"`.

        :return: The start_time_in_seconds of this Scene.
        :rtype: float
        """
        return self._start_time_in_seconds

    @start_time_in_seconds.setter
    def start_time_in_seconds(self, start_time_in_seconds):
        """Sets the start_time_in_seconds of this Scene.

        Absolute time for the scene to start. Can't be sent with `\"start_time_offset_unique_scene_id\"` and
        `\"start_time_offset_seconds\"`.

        :param start_time_in_seconds: The start_time_in_seconds of this Scene.
        :type: float
        """

        self._start_time_in_seconds = start_time_in_seconds

    @property
    def scene_start_in_seconds(self):
        """Gets the scene_start_in_seconds of this Scene.

        Stating the first frame to use from the scene in seconds. Trim the beginning of the scene.

        :return: The scene_start_in_seconds of this Scene.
        :rtype: float
        """
        return self._scene_start_in_seconds

    @scene_start_in_seconds.setter
    def scene_start_in_seconds(self, scene_start_in_seconds):
        """Sets the scene_start_in_seconds of this Scene.

        Stating the first frame to use from the scene in seconds. Trim the beginning of the scene.

        :param scene_start_in_seconds: The scene_start_in_seconds of this Scene.
        :type: float
        """

        self._scene_start_in_seconds = scene_start_in_seconds

    @property
    def media(self):
        """Gets the media of this Scene.

        Array of all the media placeholders, including image, video and color. All placeholders need to be called
        unless the defaults saved in the IDM are to be used.

        :return: The media of this Scene.
        :rtype: list[Media]
        """
        return self._media

    @media.setter
    def media(self, media):
        """Sets the media of this Scene.

        Array of all the media placeholders, including image, video and color. All placeholders need to be called
        unless the defaults saved in the IDM are to be used.

        :param media: The media of this Scene.
        :type: list[Media]
        """
        if media is None:
            media = list()

        self._media = media

    @property
    def text(self):
        """Gets the text of this Scene.

        Array of all the text placeholders. All placeholders need to be called unless the defaults saved in the IDM
        are to be used.

        :return: The text of this Scene.
        :rtype: list[Text]
        """

        return self._text

    @text.setter
    def text(self, text):
        """Sets the text of this Scene.

        Array of all the text placeholders. All placeholders need to be called unless the defaults saved in the IDM
        are to be used.

        :param text: The text of this Scene.
        :type: list[Text]
        """
        if text is None:
            text = list()

        self._text = text

    @property
    def audio(self):
        """Gets the audio of this Scene.

        Array of all the audio placeholder. All placeholders need to be called unless the defaults saved in the IDM
        are to be used.

        :return: The audio of this Scene.
        :rtype: list[Audio]
        """
        return self._audio

    @audio.setter
    def audio(self, audio):
        """Sets the audio of this Scene.

        Array of all the audio placeholder. All placeholders need to be called unless the defaults saved in the IDM
        are to be used.

        :param audio: The audio of this Scene.
        :type: list[Audio]
        """
        if audio is None:
            audio = list()

        self._audio = audio

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Scene):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
